#include <stdio.h>  
#include <string.h>  
#include <unistd.h>  
#include <sys/ioctl.h>  
#include <stdlib.h>  
#include <fcntl.h>  
#include <sys/io.h> 

#define EEPROM_SIZE				256
#define HEAD_REVISION			0x01
#define HEAD_ATOMS_NUM			2
#define OFFSET_EEPLEN			8

#define TYPE_VENDOR_INFO		0x0001
#define TYPE_CUSTOM_DATA		0x0004

#define LEN_VENDOR_STRING		0x20
#define LEN_PRODUCT_STRING		0x20

#define OVERTIME				5
#define EEPROM_DEV "/sys/bus/i2c/drivers/at24/0-0050/eeprom"
#define EEPROM_OFFSET	0x100
#define MAC_ADDR_LEN	17

struct t_eeprom_header {
	char signature[4];
	char version;
	char reversed;
	unsigned short numatoms;
	unsigned int eeplen;
};

struct t_vendor_info {
	char uuid[16];
	unsigned short pid;
	unsigned short pver;
	char vslen;
	char pslen;
	char vstr[LEN_VENDOR_STRING];
	char pstr[LEN_PRODUCT_STRING];
};

struct t_custom_info {
	unsigned short version;
	char ether_mac_0[6];
	char reversed[2];
};

struct t_atom1_info {
	unsigned short type;
	unsigned short count;
	unsigned int data_len;
	struct t_vendor_info vendor_info;
	unsigned short crc16;
};

struct t_atom4_info {
	unsigned short type;
	unsigned short count;
	unsigned int data_len;
	struct t_custom_info custom_info;
	unsigned short crc16;
};

struct t_eeprom_data {
	struct t_eeprom_header eeprom_header;
	struct t_atom1_info atom1_info;
	struct t_atom4_info atom4_info;
};

struct t_eeprom_data g_eeprom_data;

char signature[4] = {0x53, 0x46, 0x56, 0x53};	//SFVF
char starfive_vstr[LEN_VENDOR_STRING] = "StarFive Technology Co., Ltd.\0\0";
const unsigned char *mac_separator =  "-";

/* lower CRC */
const unsigned char auchCRCLo[] = 
{
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
0x40
};

/* high CRC */
const unsigned char auchCRCHi[] = 
{
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40
};


static unsigned short checksum_crc16(unsigned char *data, unsigned short len)
{                                       
    unsigned char crc_hi = 0xFF;
    unsigned char crc_lo = 0xFF;
    unsigned char i_index = 0;
    unsigned short temp = 0;

    while (len--)
    {
        i_index = crc_lo ^ *data++;      // 计算CRC
        crc_lo = crc_hi ^ auchCRCHi[i_index];
        crc_hi = auchCRCLo[i_index];
    }
    
    temp |= crc_hi;
    
    return (temp <<8 | crc_lo);
}


static char** str_split(char *src, const char *separator, int *cnt)
{
	char **dst = NULL;
	char *tmp = NULL;
	int index = 0;

	tmp = strtok(src, separator); 
	while(tmp){
		dst = realloc (dst, sizeof (char*) * ++index);
			if(dst == NULL){
				return dst;
			}
		dst[index - 1] = tmp;
		tmp = strtok(NULL, separator);
	}
	*cnt = index;
	return dst;
}

static int check_mac_addr_invalid(char *mac, int len)
{
	int i;
	int mac_invalid = 0;
	
	if(len < MAC_ADDR_LEN){
		mac_invalid = 1;
		return mac_invalid;
	}

	for(i = 0; i < len; i++){
		if((mac[i] >= '0' && mac[i] <= '9') || (mac[i] >= 'a' && mac[i] <= 'f') 
			|| (mac[i] >= 'A' && mac[i] <= 'F') || (mac[i] == '-')){
				mac_invalid = 0;
		}
		else{
			mac_invalid = 1;
			printf("bad mac address\r\n");
			break;
		}
	}
	return mac_invalid;
}

static void scan_input_mac(char *dst)
{
	char mac[20];
	int i = 0;
	int mac_invalid = 1;
	int mac_cnt;
	char **ppmac;

	while(mac_invalid){
		printf("Please enter ETH0 mac address: (xx-xx-xx-xx-xx-xx)\r\n");
		scanf("%17s[^\n]", mac);

		mac_invalid = check_mac_addr_invalid(mac, strlen(mac));
		if(i++ >= OVERTIME){
			break;
		}
	}

	if(!mac_invalid){
		ppmac = str_split(mac, mac_separator, &mac_cnt);
		if(ppmac && mac_cnt == 6){
			dst[0] = strtoul(*(ppmac + 0), NULL, 16) & 0xff;
			dst[1] = strtoul(*(ppmac + 1), NULL, 16) & 0xff;
			dst[2] = strtoul(*(ppmac + 2), NULL, 16) & 0xff;
			dst[3] = strtoul(*(ppmac + 3), NULL, 16) & 0xff;
			dst[4] = strtoul(*(ppmac + 4), NULL, 16) & 0xff;
			dst[5] = strtoul(*(ppmac + 5), NULL, 16) & 0xff;
		}
	}
	else{
		dst[0] = 0xff;
		dst[1] = 0xff;
		dst[2] = 0xff;
		dst[3] = 0xff;
		dst[4] = 0xff;
		dst[5] = 0xff;
	}
}

static void scan_input_sn(char *dst)
{
	printf("Please enter SN: (XXXXXXXX-XXXXX-XXXX-XXXXXXX)\r\n");
	scanf("%32s", dst);	
}

static unsigned char checksum(char *str, int len)
{
	int i;
	unsigned char sum = 0;

	for(i = 0; i < len; i++){
		sum += str[i];
	}
	sum = ~sum + 1;
	return sum;
}

static int eeprom_write_data(char *data, int len)
{
	int fd = 0;
	int ret = 0;
	char rbuf[EEPROM_SIZE] = {0};
	unsigned char sum = 0;

	fd = open(EEPROM_DEV, O_RDWR);  
    if(fd < 0){  
        printf("Open %s fail\n", EEPROM_DEV);  
        return -1;  
    } 

	lseek(fd, EEPROM_OFFSET, SEEK_SET);

	ret = write(fd, data, len);  
	if(ret < 0){  
		printf("Write error\n");  
		return -1;  
	}

	lseek(fd, EEPROM_OFFSET, SEEK_SET);
	ret = read(fd, rbuf, len); 
	if(ret < 0){  
		printf("Read error\n");  
		return -1;  
	}
 
	for(int i = 0; i < len; i++){
		if(i % 16 == 0)
			printf("\r\n");
		printf("%02x ", rbuf[i]);
	}
	printf("\r\n");

	close(fd);
	return 0;
}

void main(void)
{
	int i=0;
	unsigned char eth0_mac_addr[6] = {0};
	unsigned char psn[LEN_PRODUCT_STRING] = {0};

	struct t_eeprom_header *p_header = &g_eeprom_data.eeprom_header;
	struct t_atom1_info *p_atom1_info = &g_eeprom_data.atom1_info;
	struct t_atom4_info *p_atom4_info = &g_eeprom_data.atom4_info;

	memset(&g_eeprom_data, 0x0, sizeof(g_eeprom_data));

	scan_input_mac(eth0_mac_addr);
	scan_input_sn(psn);

	memcpy((void *)p_header->signature, (void *)signature, sizeof(p_header->signature));
	
	p_header->version = HEAD_REVISION;
	p_header->reversed = 0;
	p_header->numatoms = HEAD_ATOMS_NUM;
	p_header->eeplen = sizeof(g_eeprom_data);
	printf("eeplen = %d\r\n", p_header->eeplen);
	printf("eeprom_header = %ld\r\n", sizeof(g_eeprom_data.eeprom_header));
	printf("atom1_info = %ld\r\n", sizeof(g_eeprom_data.atom1_info));
	printf("atom4_info = %ld\r\n", sizeof(g_eeprom_data.atom4_info));

	p_atom1_info->type = TYPE_VENDOR_INFO;
	p_atom1_info->count = 1;
	p_atom1_info->data_len = sizeof(p_atom1_info->vendor_info) + 2;
	memset(p_atom1_info->vendor_info.uuid, 0x0, sizeof(p_atom1_info->vendor_info.uuid));
	p_atom1_info->vendor_info.pid = 0;
	p_atom1_info->vendor_info.pver = 0;
	p_atom1_info->vendor_info.vslen = LEN_VENDOR_STRING;
	p_atom1_info->vendor_info.pslen = LEN_PRODUCT_STRING;
	memcpy(p_atom1_info->vendor_info.vstr, starfive_vstr, sizeof(p_atom1_info->vendor_info.vstr));
	memcpy(p_atom1_info->vendor_info.pstr, psn, sizeof(p_atom1_info->vendor_info.pstr));
	p_atom1_info->crc16 = checksum_crc16((unsigned char *)&p_atom1_info->vendor_info, sizeof(p_atom1_info->vendor_info));

	p_atom4_info->type = TYPE_CUSTOM_DATA;
	p_atom4_info->count = 0x02;
	p_atom4_info->data_len = sizeof(p_atom4_info->custom_info) + 2;
	p_atom4_info->custom_info.version = 0x01;
	memcpy(p_atom4_info->custom_info.ether_mac_0, eth0_mac_addr, sizeof(p_atom4_info->custom_info.ether_mac_0));
	p_atom4_info->crc16 = checksum_crc16((unsigned char *)&p_atom4_info->custom_info, sizeof(p_atom4_info->custom_info));
	
	eeprom_write_data((unsigned char *)&g_eeprom_data, sizeof(g_eeprom_data));

}
